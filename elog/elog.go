package elog

import (
	"fmt"
	"github.com/natefinch/lumberjack"
	"go.uber.org/zap"
	"go.uber.org/zap/zapcore"
	"os"
	"path/filepath"
	"strings"
	"sync"
)

const SampleCfg =
`
#
# Tag representation for dir, group, filename
#    <HOSTNAME> -> hostname of current machine
#    <APP_NAME> -> binary file name of current application
#    <LOG_NAME> -> the name of current logger, in __default, it will set to elog

elog:
  __default:                          # default setting for all logs
    dir          : var/log                 # default var/log
    group        : <HOSTNAME>              # default <HOSTNAME>, if set, real dir will be $Dir/$Group
    filename     : <LOG_NAME>              # default <LOG_NAME>, will not write to file if set empty, real file path will be $Dir/$Group/$File.log
    max_size     : 100                     # default 100, unit MB
    max_backups  : 7                       # default 7
    max_age      : 7                       # default 7
    compress     : true                    # default true
    console_level: info                    # default debug     [debug, info, warn, error, fatal, panic]
    console_color: true                    # default true
    file_level   : debug                   # default debug     [debug, info, warn, error, fatal, panic]
    file_color   : false                   # default false
    stack_level  : error                   # default warn      [debug, info, warn, error, fatal, panic], base stack level

  log1:
    group   : ""
    filename: log1                         # it will set from __default if not set and will no write to file if set empty

  log2:
    filename: log2
`

// Elogger the instance for elog
type Elogger struct {
	name           string
	cfg            *Cfg
	fileWriters    map[string]zapcore.WriteSyncer		// <path, WriteSyncer>
	consoleWriters map[string]zapcore.WriteSyncer		// <name, WriteSyncer>

	fileCores      map[string]zapcore.Core
	consoleCores   map[string]zapcore.Core
}

type Elog = *zap.SugaredLogger
var dfLogger *Elogger
var loggers map[string]*Elogger
var syslog Elog
var mu sync.Mutex

func initSyslog() {
	coreConsole := zapcore.NewCore(getEncoder(true), zapcore.AddSync(os.Stdout), zapcore.DebugLevel)
	logger := zap.New(zapcore.NewTee(coreConsole), zap.AddStacktrace(zapcore.WarnLevel)).Named("[ELOG]")
	syslog = logger.Sugar()
}

// InitFromYml this will init loggers from a yaml file, note that the logger with same name will be replaced with new one
// you can get the sample cfg content from SampleCfg
func InitFromYml(file string) {

	cfgs := readCfgFromYaml(file)

	dfcfg := cfgs.Cfgs[DefaultCfgKey]

	initDfLogger(dfcfg)

	for name, cfg := range cfgs.Cfgs {
		if name == DefaultCfgKey{
			continue
		}

		NewLogger(name, cfg)
	}
}

// Log - get a log generated by DfLogger()
// the passed in option have high priority, if no options passed, it returned a default Elog
func Log(options ...Option) Elog {
	return Logger().Log(options...)
}

// Logger - get the default logger
//  - no name passed, it returned default logger
//  - passed > 1, return the first match, and "" represent to default logger
// you can init the property of DfLogger with name '__default' from yaml file
//
func Logger(name ...string) *Elogger {

	if len(name) == 0 {
		initDfLogger(nil)
		return dfLogger
	}

	mu.Lock()
	defer mu.Unlock()

	for _, _name := range name{
		if logger, ok := loggers[_name]; ok{
			return logger
		}

		if _name == "" {
			initDfLogger(nil)
			return dfLogger
		}
	}

	syslog.Fatalf("can not found any logger in names: %s", name)

	return nil
}

// NewLogger ...
func NewLogger(name string, cfg* Cfg) *Elogger {

	mu.Lock()
	defer mu.Unlock()

	if cfg == nil {
		syslog.Fatalf("generate new logger for '%s' failed: invalid cfg, nil value", name)
	}

	err := checkAndValidateCfg(name, cfg)
	if err != nil {
		syslog.Fatalf("generate new logger for '%s' failed: %s", name, err)
	}

	out := new(Elogger)

	out.name           = name
	out.cfg            = cfg
	out.fileCores      = map[string]zapcore.Core{}
	out.fileWriters    = map[string]zapcore.WriteSyncer{}
	out.consoleCores   = map[string]zapcore.Core{}
	out.consoleWriters = map[string]zapcore.WriteSyncer{}

	if loggers == nil {
		loggers = map[string]*Elogger{}
	}

	loggers[name] = out

	return out
}

// GetLog ...
// param is to set tag and filename, the first one is tag and second one is filename
// if not set, it will using cfg in logger
func (l *Elogger)Log(options ...Option) Elog {

	var logger *zap.Logger
	var path string

	opt := newOption(l.cfg, options...)

	var cores []zapcore.Core

	// setting output file core if needed
	{
		var filename string
		filename = opt.filename

		if filename != "" {
			filename = getRepresentPathValue(filename, l.name)

			if filepath.IsAbs(filename){
				path = filepath.Join(filename)
			} else if strings.HasSuffix(filename, ".log"){
				path = filepath.Join(l.cfg.Dir, l.cfg.Group, filename)
			} else {
				path = filepath.Join(l.cfg.Dir, l.cfg.Group, filename+ ".log")
			}

			cores = append(cores, l.getFileCore(path, opt))
		}
	}

	if opt.needConsole(){
		cores = append(cores, l.getConsoleCore("stdout", opt))
	}

	logger = zap.New(zapcore.NewTee(cores...), zap.AddStacktrace(l.cfg.stackLevel))

	if opt.tagSet{
		return logger.Sugar().Named(opt.tag)
	}

	return logger.Sugar()
}

func (l *Elogger)getConsoleCore(stream string, opt *option) zapcore.Core{

	switch stream {
		case "stdout": break
		case "stderr": break
		default:
			stream = "stdout"
			syslog.Warnf("invalid name '%s', only support stdout and stderr, set to stdout", stream)
	}

	cacheKey := fmt.Sprintf("%s_%d", stream, opt.consoleLevel)

	consoleCore, exist := l.consoleCores[cacheKey]
	if !exist {
		consoleCore = zapcore.NewCore(getEncoder(l.cfg.ConsoleColor), l.getConsoleWriter(stream), opt.consoleLevel)
		l.consoleCores[cacheKey] = consoleCore
	}

	return consoleCore
}

func (l *Elogger)getConsoleWriter(stream string) zapcore.WriteSyncer {

	consoleWriter, exist := l.consoleWriters[stream]
	if !exist {
		switch stream {
			case "stdout":  consoleWriter = zapcore.AddSync(os.Stdout)
							break
			case "stderr":  consoleWriter = zapcore.AddSync(os.Stderr)
							break
			default:
				stream = "stdout"
				consoleWriter = zapcore.AddSync(os.Stdout)
				syslog.Warnf("invalid name '%s', only support stdout and stderr, set to stdout", stream)
		}
		l.consoleWriters[stream] = consoleWriter
	}

	return consoleWriter
}

func (l *Elogger)getFileCore(path string, opt *option) zapcore.Core{
	cacheKey := fmt.Sprintf("%s_%d", path, opt.fileLevel)

	fileCore, exist := l.fileCores[cacheKey]
	if !exist {
		fileCore = zapcore.NewCore(getEncoder(l.cfg.FileColor), l.getFileWriter(path), opt.fileLevel)
		l.fileCores[cacheKey] = fileCore
	}

	return fileCore
}

func (l *Elogger)getFileWriter(path string) zapcore.WriteSyncer {

	fileWriter, exist := l.fileWriters[path]
	if !exist {
		fileWriter = zapcore.AddSync(&lumberjack.Logger{
			Filename:   path,
			MaxSize:    l.cfg.MaxSize,
			MaxBackups: l.cfg.MaxBackups,
			MaxAge:     l.cfg.MaxAge,
			Compress:   l.cfg.Compress,
		})
		l.fileWriters[path] = fileWriter
	}

	return fileWriter
}

func initDfLogger(cfg *Cfg) {

	if cfg == nil {
		if dfLogger == nil {
			initDfCfg()
			dfLogger = NewLogger(DefaultCfgKey, dfCfg)
		}
		return
	}

	if cfg != dfCfg{
		dfLogger = NewLogger(DefaultCfgKey, cfg)
		dfCfg = cfg
	}
}

func init() {
	initSyslog()
}

