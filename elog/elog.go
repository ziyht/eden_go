package elog

import (
	"github.com/natefinch/lumberjack"
	"go.uber.org/zap"
	"go.uber.org/zap/zapcore"
	"os"
	"path/filepath"
	"strings"
)

const SampleCfg =
`
#
# Tag representation for dir, group, filename
#    <HOSTNAME> -> hostname of current machine
#    <APP_NAME> -> binary file name of current application
#    <LOG_NAME> -> the name of current logger, in __default, it will set to elog

elog:
  __default:                          # default setting for all logs
    dir          : var/log                 # default var/log
    group        : <HOSTNAME>              # default <HOSTNAME>, if set, real dir will be $Dir/$Group
    filename     : <LOG_NAME>              # default <LOG_NAME>, will not write to file if set empty, real file path will be $Dir/$Group/$File
    max_size     : 100                     # default 100, unit MB
    max_backups  : 7                       # default 7
    max_age      : 7                       # default 7
    compress     : true                    # default true
    console_level: info                    # default debug     [debug, info, warn, error, fatal, panic]
    console_color: true                    # default true
    file_level   : debug                   # default debug     [debug, info, warn, error, fatal, panic]
    file_color   : false                   # default false
    stack_level  : error                   # default warn      [debug, info, warn, error, fatal, panic], base stack level

  log1:
    group   : ""
    filename: log1                         # it will set from __default if not set and will no write to file if set empty

  log2:
    filename: log2
`

// Logger the instance for elog
type Logger struct {
	cfg            *Cfg
	fileWriters    map[string]zapcore.WriteSyncer		// <path, WriteSyncer>
	consoleWriters map[string]zapcore.WriteSyncer		// <name, WriteSyncer>

	fileCores      map[string]zapcore.Core
	consoleCores   map[string]zapcore.Core
}

type Log = *zap.SugaredLogger
var dfLogger *Logger
var loggers map[string]*Logger
var syslog Log

func initSyslog() {
	coreConsole := zapcore.NewCore(getEncoder(true), zapcore.AddSync(os.Stdout), zapcore.DebugLevel)
	logger := zap.New(zapcore.NewTee(coreConsole), zap.AddStacktrace(zapcore.WarnLevel)).Named("[ELOG]")
	syslog = logger.Sugar()
}

// InitFromYml this will init loggers from a yaml file, note that the logger with same name will be replaced with new one
// you can get the sample cfg content from SampleCfg
func InitFromYml(file string) {

	cfgs := readCfgFromYaml(file)

	dfcfg := cfgs.Cfgs[DefaultCfgKey]

	initDfLogger(dfcfg)

	for name, cfg := range cfgs.Cfgs {
		if name == DefaultCfgKey{
			continue
		}

		NewLogger(name, cfg)
	}
}

// DfLog get a default log, it generated by DfLogger()
func DfLog() Log {
	return GetLog()
}

// GetLog get a log generated by DfLogger()
// the passed in option have high priority
func GetLog(options ...Option) Log {
	return DfLogger().GetLog(options...)
}

// DfLogger get the default logger
// if not set from file and so on, it will generated by default cfg
// you can init the property of DfLogger with name '__default' from yaml file
func DfLogger() *Logger {
	initDfLogger(nil)
	return dfLogger
}

// NewLogger ...
func NewLogger(name string, cfg* Cfg) *Logger {

	if cfg == nil {
		syslog.Fatalf("generate new logger for '%s' failed: invalid cfg, nil value", name)
	}

	err := checkAndValidateCfg(name, cfg)
	if err != nil {
		syslog.Fatalf("generate new logger for '%s' failed: %s", name, err)
	}

	out := new(Logger)

	out.cfg            = cfg
	out.fileCores      = map[string]zapcore.Core{}
	out.fileWriters    = map[string]zapcore.WriteSyncer{}
	out.consoleCores   = map[string]zapcore.Core{}
	out.consoleWriters = map[string]zapcore.WriteSyncer{}

	if loggers == nil {
		loggers = map[string]*Logger{}
	}

	loggers[name] = out

	return out
}

func GetLogger(name string) *Logger {

	if logger, ok := loggers[name]; ok{
		return logger
	}

	return nil
}

// GetLog ...
// param is to set tag and filename, the first one is tag and second one is filename
// if not set, it will using cfg in logger
func (l *Logger)GetLog(options ...Option) Log {

	var logger *zap.Logger
	var path string

	var opt option
	for _, op := range options{
		op.apply(&opt)
	}

	var cores []zapcore.Core

	// setting output file core if needed
	{
		var filename string
		if opt.filenameSet {
			filename = opt.filename			// set filename from param
		} else {
			filename = l.cfg.FileName		// get default filename set by cfg
		}

		if filename != "" {
			if filepath.IsAbs(filename){
				path = filepath.Join(filename)
			} else if strings.HasSuffix(filename, ".log"){
				path = filepath.Join(l.cfg.Dir, l.cfg.Group, filename)
			} else {
				path = filepath.Join(l.cfg.Dir, l.cfg.Group, filename+ ".log")
			}

			cores = append(cores, l.getFileCore(path))
		}
	}

	cores = append(cores, l.getConsoleCore("stdout"))

	logger = zap.New(zapcore.NewTee(cores...), zap.AddStacktrace(l.cfg.stackLevel))

	if opt.tagSet{
		return logger.Sugar().Named(opt.tag)
	}

	return logger.Sugar()
}

func (l *Logger)getConsoleCore(name string) zapcore.Core{

	switch name {
		case "stdout": break
		case "stderr": break
		default:
			name = "stdout"
			syslog.Warnf("invalid name '%s', only support stdout and stderr, set to stdout", name)
	}

	consoleCore, exist := l.fileCores[name]
	if !exist {
		consoleCore = zapcore.NewCore(getEncoder(l.cfg.ConsoleColor), l.getConsoleWriter(name), l.cfg.consoleLevel)
		l.fileCores[name] = consoleCore
	}

	return consoleCore
}

func (l *Logger)getConsoleWriter(name string) zapcore.WriteSyncer {

	consoleWriter, exist := l.consoleWriters[name]
	if !exist {
		switch name {
			case "stdout":  consoleWriter = zapcore.AddSync(os.Stdout)
							break
			case "stderr":  consoleWriter = zapcore.AddSync(os.Stderr)
							break
			default:
				name = "stdout"
				consoleWriter = zapcore.AddSync(os.Stdout)
				syslog.Warnf("invalid name '%s', only support stdout and stderr, set to stdout", name)
		}
		l.consoleWriters[name] = consoleWriter
	}

	return consoleWriter
}

func (l *Logger)getFileCore(path string) zapcore.Core{
	fileCore, exist := l.fileCores[path]
	if !exist {
		fileCore = zapcore.NewCore(getEncoder(l.cfg.FileColor), l.getFileWriter(path), l.cfg.fileLevel)
		l.fileCores[path] = fileCore
	}

	return fileCore
}

func (l *Logger)getFileWriter(path string) zapcore.WriteSyncer {

	fileWriter, exist := l.fileWriters[path]
	if !exist {
		fileWriter = zapcore.AddSync(&lumberjack.Logger{
			Filename:   path,
			MaxSize:    l.cfg.MaxSize,
			MaxBackups: l.cfg.MaxBackups,
			MaxAge:     l.cfg.MaxAge,
			Compress:   l.cfg.Compress,
		})
		l.fileWriters[path] = fileWriter
	}

	return fileWriter
}




func initDfLogger(cfg *Cfg) {

	if cfg == nil {
		if dfLogger == nil {
			initDfCfg()
			dfLogger = NewLogger("", dfCfg)
		}
		return
	}

	dfLogger = NewLogger("", cfg)
}

func init() {
	initSyslog()
}

