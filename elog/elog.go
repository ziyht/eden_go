package elog

import (
	"go.uber.org/zap"
	"go.uber.org/zap/zapcore"
	"os"
	"path/filepath"
	"strings"
)

const SampleCfg =
`
elog:
  __default:                          # default setting for all logs
    dir          : var/log                 # default var/log
    group        : <HOSTNAME>              # default <HOSTNAME>, if set, real dir will be $Dir/$Group,  <HOSTNAME> represent hostname of current machine
    filename     : elog                    # default elog(will set to elog if not set), will not write to file if set empty, real file path will be $Dir/$Group/$File, you can also use <HOSTNAME> to represent hostname of current machine
    max_size     : 100                     # default 100, unit MB
    max_backups  : 7                       # default 7
    max_age      : 7                       # default 7
    compress     : true                    # default true
    console_level: info                    # default debug     [debug, info, warn, error, fatal, panic]
    console_color: true                    # default true
    file_level   : debug                   # default debug     [debug, info, warn, error, fatal, panic]
    file_color   : false                   # default false
    stack_level  : warn                    # default warn      [debug, info, warn, error, fatal, panic], base stack level

  log1:
    group   : ""
    filename: log1                         # it will set from __default if not set and will no write to file if set empty

  log2:
    filename: log2
`

// Logger the instance for elog
type Logger struct {
	cfg           *Cfg
	fileWriters   map[string]zapcore.WriteSyncer		// <path, WriteSyncer>
	consoleWriter zapcore.WriteSyncer
}

type Log = *zap.SugaredLogger
var dfLogger *Logger
var loggers map[string]*Logger
var syslog Log

func initSyslog() {
	coreConsole := zapcore.NewCore(getEncoder(true), zapcore.AddSync(os.Stdout), zapcore.DebugLevel)
	logger := zap.New(zapcore.NewTee(coreConsole), zap.AddStacktrace(zapcore.WarnLevel)).Named("[ELOG]")
	syslog = logger.Sugar()
}

// InitFromYml this will init loggers from a yaml file, note that the logger with same name will be replaced with new one
func InitFromYml(file string) {

	cfgs := readCfgFromYaml(file)

	dfcfg := cfgs.Cfgs[DefaultCfgKey]

	initDfLogger(dfcfg)

	for name, cfg := range cfgs.Cfgs {
		if name == DefaultCfgKey{
			continue
		}
		NewLogger(name, cfg)
	}
}

// DfLog get a default log, it generated by DfLogger()
// you can init the property of DfLogger with name '__default' from yaml file
func DfLog() Log {
	return GetLog()
}

// GetLog get a log generated by DfLogger()
func GetLog(filename_ ...string) Log {
	return DfLogger().GetLog(filename_...)
}

// DfLogger get the default logger
// if not set from file and so on, it will generated by default cfg
func DfLogger() *Logger {
	initDfLogger(nil)
	return dfLogger
}

// NewLogger ...
func NewLogger(name string, cfg* Cfg) *Logger {

	if cfg == nil {
		syslog.Fatalf("generate new logger for '%s' failed: invalid cfg, nil value", name)
	}

	err := checkAndValidateCfg(cfg)
	if err != nil {
		syslog.Fatalf("generate new logger for '%s' failed: %s", name, err)
	}

	out := new(Logger)

	out.cfg           = cfg
	out.fileWriters   = map[string]zapcore.WriteSyncer{}
	out.consoleWriter = zapcore.AddSync(os.Stdout)

	if loggers == nil {
		loggers = map[string]*Logger{}
	}

	loggers[name] = out

	return out
}

func GetLogger(name string) *Logger {

	if logger, ok := loggers[name]; ok{
		return logger
	}

	return nil
}

// GetLog ...
func (l *Logger)GetLog(filename ...string) Log {

	var logger *zap.Logger
	var path string
	var filename_ string

	if len(filename) == 0{
		filename_ = l.cfg.FileName
	} else {
		filename_ = filename[0]
	}

	var cores []zapcore.Core

	if filename_ != "" {
		if filepath.IsAbs(filename_){
			path = filepath.Join(filename_)
		} else if strings.HasSuffix(filename_, ".log"){
			path = filepath.Join(l.cfg.Dir, l.cfg.Group, filename_)
		} else {
			path = filepath.Join(l.cfg.Dir, l.cfg.Group, filename_+ ".log")
		}

		fileWriter, exist := l.fileWriters[path]
		if !exist {
			fileWriter = l.genLogWriter(path)
			l.fileWriters[path] = fileWriter
		}

		cores = append(cores, zapcore.NewCore(getEncoder(l.cfg.ConsoleColor), fileWriter, l.cfg.fileLevel))
	}

	cores = append(cores, zapcore.NewCore(getEncoder(l.cfg.ConsoleColor), l.consoleWriter, l.cfg.consoleLevel))
	cores = append(cores)

	logger = zap.New(zapcore.NewTee(cores...), zap.AddStacktrace(l.cfg.stackLevel))

	return logger.Sugar()
}

func (l *Logger)genLogWriter(path string) zapcore.WriteSyncer {
	lumberJackLogger := &lumberjack.Logger{
		Filename:   path,
		MaxSize:    l.cfg.MaxSize,
		MaxBackups: l.cfg.MaxBackups,
		MaxAge:     l.cfg.MaxAge,
		Compress:   l.cfg.Compress,
	}
	return zapcore.AddSync(lumberJackLogger)
}

func initDfLogger(cfg *Cfg) {

	if cfg == nil {
		if dfLogger == nil {
			initDfCfg()
			dfLogger = NewLogger("", dfCfg)
		}
		return
	}

	dfLogger = NewLogger("", cfg)
}

func init() {
	initSyslog()
}

