package elog

var (
	version = "1.0.0"
)

// InitFromConfigFile this will init loggers from a config file, support multi file types like yaml, json,...
// note that the logger with same name will be replaced with new one
// you can get the sample cfg content from SampleCfg()
func InitFromFile(path string) {

	cfgs := readCfgFromFile(path)

	initDfLogger(&dfCfg)

	for name, cfg := range cfgs.Cfgs {
		NewLogger(name, cfg)
	}
}

func SampleCfgStr() string {
	return sampleCfg
}

// GenDfCfg - returned a new dfCfg, it will always be the same
func GenDfCfg(name string) *Cfg {
	return genDfCfg().Clone(name)
}

// DfCfg - return the dfCfg, note: dfCfg can be changed by init operations 
func DfCfg() Cfg {
	return dfCfg
}

// NewLogger generator a new Elogger
func NewLogger(name string, cfg* Cfg) *Elogger {
	return newElogger(name, cfg)
}

// Logger - get a logger by name
//  - no name passed, it returned default logger
//  - passed > 1, return the first match, and "" represent to default logger(lowest priority)
//  - if not found, return nil
func Logger(name ...string) *Elogger {
	return getLogger(name...)
}

// Log - get a log instance by a logger
func (l *Elogger)Log(options ...Option) Elog {
	return l.getLog(options...)
}

// return the Cfg of logger
func (l *Elogger)Cfg() *Cfg {
	return l.cfg.Clone(l.cfg.name)
}

// return the name of logger
func (l *Elogger)Name() string {
	return l.cfg.name
}

// Log - get a log generated by DfLogger()
// the passed in option have high priority, if no options passed, it returned a default Elog
func Log(options ...Option) Elog {
	return Logger().Log(options...)
}

func Version() string{
	return version
}