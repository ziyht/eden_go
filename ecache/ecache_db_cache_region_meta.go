package ecache

var (
  /*
  raw key will be generated by those following formats
	we assuming the keys to build region not contains the split span like 4, 5, ...
	
	regions list:
  -- store key ----------          -- region --
	5 key1 5 key2 7                  [key1,key2]
	5 key1 5 key2 4 skey1 7          [key1,key2].[skey1]
  5 key1 7                         [key1]
	5 key1 4 skey1 7                 [key1].[skey1]
  5 key1 4 skey2 7                 [key1].[skey2]
  
	we can scan prefix 5 to list all stored regions(including sub regions)
	
	infos for regions:
  -- store key ---------------------          -- region --
	6 key1 5 key2 7           'info1'           [key1,key2]
	6 key1 5 key2 7           'info2'           [key1,key2]
	6 key1 5 key2 7           'info3'           [key1,key2]
	6 key1 5 key2 7           '...'             [key1,key2]
	6 key1 5 key2 4 skey1 7   'info1'           [key1,key2].[skey1]
  6 key1 7                  'info1'           [key1]
	6 key1 4 skey1 7          'info1'           [key1].[skey1]
  6 key1 4 skey2 7          'info1'           [key1].[skey2]

	when we want to scan info s for a region, we can scan prefix like this: 6 key1 5 key2 7

	records for regions:
  -- store key ---------------------          -- region --
	7 key1 5 key2 6 key1                        [key1,key2]
	7 key1 5 key2 6 key2                        [key1,key2]
	7 key1 5 key2 4 skey1 6 key1                [key1,key2].[skey1]

	when we want to scan keys for a region, we can scan prefix like this: 7 key1 5 key2 6

	*/
	__r_pre = []byte{5}   // for regions list raw key building 
	__r_gap = []byte{5}
	__r_pos = []byte{7}
	__i_pre = []byte{6}   // for regions info raw key building 
	__i_gap = []byte{5}
	__i_pos = []byte{7}
	__k_pre = []byte{7}   // for regions records raw key building 
	__k_gap = []byte{5}
	__k_pos = []byte{6}
	__I_pre = []byte{7}   // for regions records raw key building, for items
	__I_gap = []byte{5}
	__I_pos = []byte{7}

	__sk_gap = []byte{4}  // for connecting between region and sub regions
)

type rMeta struct {
  pkeys     [][]string    // store  parents region keys
	keys      []string      // stores my keys
	rpre      []byte        // caching the regions list    key prefix
  ipre      []byte        // caching the regions infos   key prefix
	kpre      []byte        // caching the regions records key prefix
	kpreLen   int
}

func (m *rMeta) init(keys []string)  {
	m.keys  = keys
	m.rpre  = m.genKeyPre(__r_pre, __r_gap, __r_pos, keys)
	m.ipre  = m.genKeyPre(__i_pre, __i_gap, __i_pos, keys)
	m.kpre  = m.genKeyPre(__k_pre, __k_gap, __k_pos, keys)

	m.kpreLen = len(m.kpre)
}

func (m *rMeta) initItem(keys []string)  {
	m.keys  = keys
	m.rpre  = m.genKeyPre(__r_pre, __r_gap, __r_pos, keys)
	m.ipre  = m.genKeyPre(__i_pre, __i_gap, __i_pos, keys)
	m.kpre  = m.genKeyPre(__I_pre, __I_gap, __I_pos, keys)

	m.kpreLen = len(m.kpre)
}

func (m *rMeta)genSubMeta(keys []string)	rMeta{
	o := &rMeta{keys: keys}
	o.pkeys = append(o.pkeys, m.pkeys...)
	o.pkeys = append(o.pkeys, m.keys)
	o.ipre = m.catSubForKeyPre(__r_pre, __r_gap, __r_pos, __sk_gap, m.ipre, keys)
	o.ipre = m.catSubForKeyPre(__i_pre, __i_gap, __i_pos, __sk_gap, m.ipre, keys)
	o.kpre = m.catSubForKeyPre(__k_pre, __k_gap, __k_pos, __sk_gap, m.kpre, keys)
	o.kpreLen = len(o.kpre)

	return *o
}

// pre {k1} gap {k2} gap ... pos
func (m *rMeta)genKeyPre(pre, gap, pos []byte, keys []string) ([]byte) {
	o := make([]byte, 0, 8)
	o = append(o, pre...)

	for _, k := range keys {
		o = append(o, k...)
		o = append(o, gap...)
	}
	if len(keys) > 0 {
		o = o[:len(o)-len(gap)]
	}
	o = append(o, pos...)
	return o
}

func (m *rMeta)catSubForKeyPre(pre, gap, pos, sk_gap []byte, kpre []byte, keys []string)([]byte){

	o := make([]byte, 0, len(kpre) + 8)
	o = append(o, kpre...)
	o = o[:len(o)-len(pos)]
	o = append(o, sk_gap...)
	for _, k := range keys {
		o = append(o, k...)
		o = append(o, gap...)
	}
	if len(keys) > 0 { 
		o = o[:len(o)-len(gap)]
	}
	o = append(o, pos...)
	return o
}
